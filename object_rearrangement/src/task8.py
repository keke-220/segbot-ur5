# -*- coding: utf-8 -*-
"""set_table_gpt_v5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cSqoSc6Gk9KM9p-GwHSIIL5VfZICGW3B

#**Interactive Demo of Setting Dining Table**
<!-- <img src="https://raw.githubusercontent.com/yding25/pic_share/master/set_table.png" height="400" /> -->
<img src="https://raw.githubusercontent.com/yding25/pic_share/master/set_table_basic.png" height="350" />

A service robot is required to arrange the dining table. The robot has knowledge only of the utensils required. It must calculate the positioning of these utensils.

**Instructions:**

1) Obtain an [API Key](https://openai.com/blog/openai-api/) for GPT-3

2) Choose the dining table utensils

3) Execute all code cells to determine the utensil positions

4) (Optional) Create a video showcasing a robotic arm picking and placing the selected utensils
"""

#@title Customized parameters{display-mode: "form"}

#@markdown Input an API Key for GPT-3
api_key = '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'  #@param {type:"string"}

#@markdown Hint: If you select 'ChatGPT,' you'll need to manually retrieve the response through a web browser because of unavailability of the API.
gpt_model = "text-davinci-003"  #@param ["text-davinci-003", "text-curie-001", "text-babbage-001", "text-ada-001"]

#@markdown Choose the dining table utensils or foods (#25 items):

#@markdown Plate & Bowl Category:
has_bread_plate = False  #@param {type:"boolean"}
has_dinner_plate = True  #@param {type:"boolean"}
has_teacup_plate = False  #@param {type:"boolean"}
has_fruit_bowl = False  #@param {type:"boolean"}

#@markdown Fork Category:
has_dinner_fork = True  #@param {type:"boolean"}
has_salad_fork = False  #@param {type:"boolean"}
has_dessert_fork = False  #@param {type:"boolean"}
has_seafood_fork = False  #@param {type:"boolean"}
has_fork = False  #@param {type:"boolean"}

#@markdown Knife Category:
has_butter_knife = False  #@param {type:"boolean"}
has_dinner_knife = True  #@param {type:"boolean"}
has_fish_knife = False  #@param {type:"boolean"}

#@markdown Spoon Category:
has_soup_spoon = False  #@param {type:"boolean"}
has_dessert_spoon = False  #@param {type:"boolean"}
has_tea_spoon = False  #@param {type:"boolean"}

#@markdown Cup & Glass Category:
has_water_cup = False  #@param {type:"boolean"}
has_wine_glass = False  #@param {type:"boolean"}
has_teacup = True  #@param {type:"boolean"}

#@markdown Food Category:
has_bread = False  #@param {type:"boolean"}
has_strawberry = False  #@param {type:"boolean"}

#@markdown Others:
has_napkin = False  #@param {type:"boolean"}
has_place_mat = False  #@param {type:"boolean"}
has_salt_shaker = False  #@param {type:"boolean"}
has_pepper_shaker = False  #@param {type:"boolean"}
has_teacup_mat = False  #@param {type:"boolean"}
has_teacup_lid = True  #@param {type:"boolean"}

import copy
import gc
import itertools
import json
import math
import os
#@markdown ----
#@markdown (for testing) randomly choose utensils on a dining table
import random
import re
import subprocess
import sys
import tempfile
import textwrap
import time
from base64 import b64encode

import matplotlib.pyplot as plt
import numpy as np
import openai
from PIL import Image

import cv2

random_choose = False  #@param {type:"boolean"}
if random_choose:
    num_utensil = "3"  #@param ["3"]
    items = [False] * 24
    for i in range(int(num_utensil)):
        items[i] = True
    random.shuffle(items)
    has_bread_plate, has_dinner_plate, has_fruit_bowl, has_dinner_fork, has_salad_fork, has_dessert_fork, has_seafood_fork, has_butter_knife, has_dinner_knife, has_fish_knife, has_soup_spoon, has_dessert_spoon, has_tea_spoon, has_water_cup, has_wine_glass, has_teacup, has_bread, has_strawberry, has_napkin, has_place_mat, has_salt_shaker, has_pepper_shaker, has_teacup_mat, has_teacup_lid = items

# process the input parameters from users
utensils = [
    {
        "name": "bread plate",
        "has": has_bread_plate
    },
    {
        "name": "butter knife",
        "has": has_butter_knife
    },
    {
        "name": "dinner fork",
        "has": has_dinner_fork
    },
    {
        "name": "soup spoon",
        "has": has_soup_spoon
    },
    {
        "name": "water cup",
        "has": has_water_cup
    },
    {
        "name": "wine glass",
        "has": has_wine_glass
    },
    {
        "name": "napkin",
        "has": has_napkin
    },
    {
        "name": "dinner knife",
        "has": has_dinner_knife
    },
    {
        "name": "dinner plate",
        "has": has_dinner_plate
    },
    {
        "name": "salad fork",
        "has": has_salad_fork
    },
    {
        "name": "dessert fork",
        "has": has_dessert_fork
    },
    {
        "name": "dessert spoon",
        "has": has_dessert_spoon
    },
    {
        "name": "tea spoon",
        "has": has_tea_spoon
    },
    {
        "name": "seafood fork",
        "has": has_seafood_fork
    },
    {
        "name": "fish knife",
        "has": has_fish_knife
    },
    {
        "name": "place mat",
        "has": has_place_mat
    },
    {
        "name": "salt shaker",
        "has": has_salt_shaker
    },
    {
        "name": "pepper shaker",
        "has": has_pepper_shaker
    },
    {
        "name": "bread",
        "has": has_bread
    },  # new
    {
        "name": "teacup mat",
        "has": has_teacup_mat
    },
    {
        "name": "strawberry",
        "has": has_strawberry
    },
    {
        "name": "fruit bowl",
        "has": has_fruit_bowl
    },
    {
        "name": "teacup",
        "has": has_teacup
    },
    {
        "name": "teacup lid",
        "has": has_teacup_lid
    },
    {
        "name": "fork",
        "has": has_fork
    }
]
utensil_name = []  # save utensils' name
for utensil in utensils:
    if utensil["has"]:
        utensil_name.append(utensil["name"])
print('utensil to be placed on a dining table:\n{}'.format(utensil_name))

relationship_name = [
    'above', 'to the right of', 'below', 'to the left of',
    'above and to the right of', 'below and to the right of',
    'below and to the left of', 'above and to the left of', 'on top of',
    'under', 'center'
]
print('\npredefined relationships between two utensils on a table:\n{}'.format(
    relationship_name))

#@title Input utensil size and table information (unit of meter) {display-mode: "form"}

#@markdown Hint: These sizes correspond to the object sizes in the simulator. You can change them to fit your own objects.
'''
utensil size by defalut
'''

#@markdown Plate & Bowl Category:
bread_plate_width_length_height = "0.1, 0.1, 0.03"  #@param {type:"string"}
dinner_plate_width_length_height = "0.12, 0.12, 0.03"  #@param {type:"string"}
fruit_bowl_width_length_height = "0.15, 0.15, 0.07"  #@param {type:"string"}

#@markdown Fork Category:
dinner_fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}
salad_fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}
dessert_fork_width_length_height = "0.17, 0.05, 0.03"  #@param {type:"string"}
seafood_fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}
fork_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}

#@markdown Knife Category:
butter_knife_width_length_height = "0.19, 0.05, 0.03"  #@param {type:"string"}
dinner_knife_width_length_height = "0.22, 0.05, 0.03"  #@param {type:"string"}
fish_knife_width_length_height = "0.22, 0.05, 0.03"  #@param {type:"string"}

#@markdown Spoon Category:
dessert_spoon_width_length_height = "0.17, 0.05, 0.03"  #@param {type:"string"}
tea_spoon_width_length_height = "0.17, 0.05, 0.03"  #@param {type:"string"}

#@markdown Spoon Category:
soup_spoon_width_length_height = "0.2, 0.05, 0.03"  #@param {type:"string"}

#@markdown Cup & Glass Category:
water_cup_width_length_height = "0.09, 0.09, 0.13"  #@param {type:"string"}
wine_glass_width_length_height = "0.07, 0.07, 0.17"  #@param {type:"string"}
teacup_width_length_height = "0.12, 0.08, 0.1"  #@param {type:"string"}

#@markdown Food Category:
bread_width_length_height = "0.1, 0.1, 0.06"  #@param {type:"string"}
strawberry_width_length_height = "0.1, 0.1, 0.05"  #@param {type:"string"}

#@markdown Others:
napkin_width_length_height = "0.1, 0.25, 0.03"  #@param {type:"string"}
place_mat_width_length_height = "0.12, 0.12, 0.03"  #@param {type:"string"}
salt_shaker_width_length_height = "0.06, 0.06, 0.1"  #@param {type:"string"}
pepper_shaker_width_length_height = "0.06, 0.06, 0.1"  #@param {type:"string"}
teacup_mat_width_length_height = "0.12, 0.12, 0.03"  #@param {type:"string"}
teacup_lid_width_length_height = "0.06, 0.06, 0.03"  #@param {type:"string"}

#@markdown Table info {display-mode: "form", vertical-output: true }
boundary_min_x = -0.25  #@param {type:"number"}
boundary_max_x = 0.25  #@param {type:"number"}
boundary_min_y = 0.25  #@param {type:"number"}
boundary_max_y = -0.25  #@param {type:"number"}
beta = 1.0
boundary_min_x = beta * boundary_min_x
boundary_max_x = beta * boundary_max_x
boundary_min_y = beta * boundary_min_y
boundary_max_y = beta * boundary_max_y
table_x, table_y = (boundary_min_x + boundary_max_x) / 2, (boundary_min_y +
                                                           boundary_max_y) / 2
table_width, table_length = abs(boundary_max_x -
                                boundary_min_x), abs(boundary_max_y -
                                                     boundary_min_y)
"""# Setup"""

#@title Utils {display-mode: "form"}
openai.api_key = api_key

# process utensil size according user's input
utensil_size = {}
pattern = "([0-9]*\.[0-9]*)"
alpha = 1.05  # expand object size
for utensil in utensil_name:
    variable_name = utensil.replace(" ", "_")
    matches = re.findall(pattern, eval(variable_name + "_width_length_height"))
    utensil_size[utensil] = [
        float(matches[0]) * alpha,
        float(matches[1]) * alpha,
        float(matches[2]) * alpha
    ]

# intialize utensils' pose
utensil_init_pose = {}
for utensil in utensils:
    if utensil["has"]:
        utensil_init_pose[utensil["name"]] = [[
            1.15, -0.18, 0.65 + utensil_size[utensil["name"]][2]
        ], [0, 0, 0, 1]]


def count_tokens(text):
    return len(text.split())


def fee_tokens(text):
    if gpt_model == "text-davinci-003":
        return round(len(text.split()) / 1000.0 * 0.02, 3)
    elif gpt_model == "text-curie-001":
        return round(len(text.split()) / 1000.0 * 0.002, 3)
    elif gpt_model == "text-babbage-001":
        return round(len(text.split()) / 1000.0 * 0.0005, 3)
    elif gpt_model == "text-ada-001":
        return round(len(text.split()) / 1000.0 * 0.0004, 3)
    elif gpt_model == "ChatGPT":
        return round(len(text.split()) / 1000.0 * 0.0, 3)


def create_prompt_relationship(input, zeroshot=True):
    '''
  @input: a list of several utensils, e.g., ['fork', 'plate']
  @output: a sentence of prompt, e.g., How to place a fork, and a plate on a table?
  '''
    utensils = ''
    for index in range(len(input)):
        if index < len(input) - 1:
            utensils += 'a ' + input[index] + ', '
        else:
            utensils += 'and a ' + input[index] + ' '

    prompt_hint = 'The goal is to arrange a dining table with objects. The spatial relationship between two objects includes only one of the following options: above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on top of, under, and center.\n\n'
    if zeroshot:
        prompt_example = ''
    else:
        prompt_example = '###\nWhat is a typical way of positioning a water cup and a dinner plate on a table?\n1. Place the dinner plate in the center of the table.\n2. Place the water cup above and to the right of the dinner plate.\n\n###\nWhat is a typical way of positioning a dinner fork and a dinner knife on a table?\n1. Place the dinner fork to the left of the dinner knife.\n\n###\n'
    prompt_question = 'What is a typical way of positioning ' + utensils + 'on a table? '
    prompt_note = 'Note each action should be on a separate line starting with Place. The answer cannot include other objects.'
    # prompt_note = ''
    return prompt_hint + prompt_example + prompt_question + prompt_note


def create_prompt_distance(input):
    '''
  @input: object A, object B, spatial relationship, e.g., ['bread_plate', 'dessert fork']
  @output: a sentence of prompt
  '''
    prompt_hint = 'a ' + input[0] + ' is placed ' + input[2] + ' a ' + input[
        1] + '. '
    if input[2] == 'above' or input[2] == 'to the right of' or input[
            2] == 'below' or input[2] == 'to the left of' or input[
                2] == 'above':
        prompt_question = 'how many centimeters ' + input[2] + ' the ' + input[
            1] + ' should the ' + input[0] + ' be placed' + '?'
    else:
        prompt_question = 'how many centimeters ' + input[2] + ' the ' + item[
            1] + ' should the ' + item[0] + ' be placed' + '? '
    return prompt_hint + prompt_question


def extract_object_relationship(commonsense, utensil_name, relationship_name):
    '''
  @commonsense: a sentence, e.g., 'place the plate in the center of the table.'; utensil_name and relationship_name are fixed
  @output: a sentence, e.g., 'object a: plate, object b: table, relationship: center'
  '''
    utensil_name = utensil_name + ['table'
                                   ]  # table is not in utensil_name by default
    # extract object A and B in commonsense
    objects = []
    for item in utensil_name:
        matches = re.finditer(item, commonsense)
        for match in matches:
            objects.append((item, match.start()))
    objects.sort(key=lambda x: x[1])

    # corner case: 'bread' and 'bread plate'; 'teacup' and 'teacup lid'
    # print('objects (before):{}'.format(objects))
    def check_same_number(list_a):
        temp = []
        for i in range(len(list_a)):
            for j in range(i + 1, len(list_a)):
                if list_a[i][1] == list_a[j][1]:
                    if len(list_a[i][0]) < len(list_a[j][0]):
                        temp.append(i)
                    else:
                        temp.append(j)
        list_a_temp = []
        for i in range(len(list_a)):
            if i not in temp:
                list_a_temp.append(list_a[i])
        return list_a_temp

    objects = check_same_number(objects)
    # print('objects (after):{}'.format(objects))

    if len(objects) == 2:  # commonsense has two objects
        object_A = objects[0][0]
        object_B = objects[1][0]
    elif len(objects) != 2:
        print("!Error: Expected 2 unique objects but found {}".format(objects))
        print("commonsense: {}".format(commonsense))
        sys.exit()

    # extract "relationship" from commonsense
    relationship = []
    for item in relationship_name:
        if re.search(item, commonsense):
            relationship.append(item)

    if len(relationship) > 1:  # processs corner cases
        if 'on' in relationship:
            relationship.remove('on')
        if 'above' in relationship:
            relationship.remove('above')
        if 'below' in relationship:
            relationship.remove('below')
        if 'to the left of' in relationship:
            relationship.remove('to the left of')
        if 'to the right of' in relationship:
            relationship.remove('to the right of')
    if len(relationship) != 1:
        print("!Error: Expected 1 relationship but found {}".format(
            len(relationship)))
        print("commonsense: {}".format(commonsense))
        sys.exit()

    return object_A, object_B, relationship[0]


def opposite_direction(relationship):
    if 'above' == relationship:
        return 'below'
    elif 'below' == relationship:
        return 'above'
    elif 'to the left of' == relationship:
        return 'to the right of'
    elif 'to the right of' == relationship:
        return 'to the left of'
    elif 'above and to the right of' == relationship:
        return 'below and to the left of'
    elif 'below and to the right of' == relationship:
        return 'above and to the left of'
    elif 'below and to the left of' == relationship:
        return 'above and to the right of'
    elif 'above and to the left of' == relationship:
        return 'below and to the right of'
    elif 'on top of' == relationship:
        return 'under'
    else:
        print('!Error: Unexpected relationship: {}'.format(relationship))
        sys.exit()
        return None


def extract_distance(commonsense_concrete, type):
    '''
  @commonsense_concrete: a sentence, e.g., 'the distance between the bread plate and the plate will depend on the size of the plates. generally, the distance between the two plates should be around 10-15 centimeters.'
  @output: a distance value, e.g., 14
  '''
    res = re.findall(r'\d+', commonsense_concrete)
    if type == 'type1':  #'above' or 'below'
        if len(res) not in (1, 2):
            print("!Warning: Expected 1-2 values but found {}".format(
                len(res)))
            return 5, 0
        if len(res) == 1:
            return int(res[0]), 0
        # return random.randint(int(res[0]), int(res[1])), 0
        return (int(res[0]) + int(res[1])) / 2.0, 0
    if type == 'type2':  # 'to the right of' or 'to the left of'
        if len(res) not in (1, 2):
            print("!Warning: Expected 1-2 values but found {}".format(
                len(res)))
            return 0, 5
        if len(res) == 1:
            return 0, int(res[0])
        # return 0, random.randint(int(res[0]), int(res[1]))
        return 0, (int(res[0]) + int(res[1])) / 2.0
    if type == 'type3':  # 'above and to the right of' or 'below and to the right of' or 'below and to the left of' or 'above and to the left of':
        if len(res) not in (1, 2):
            print("!Warning: Expected 1-2 values but found {}".format(
                len(res)))
            return 3.5, 3.5
        if len(res) == 1:
            return int(math.sqrt(int(res[0]))), int(math.sqrt(int(res[0])))
        return int(math.sqrt(random.randint(int(res[0]), int(res[1])))), int(
            math.sqrt(random.randint(int(res[0]), int(res[1]))))


def llm(prompt):  # call LLM
    sampling_params = {
        "n": 1,
        "max_tokens": 512,
        "temperature": 0.1,
        "top_p": 1,
        "logprobs": 1,
        "presence_penalty": 0,
        "frequency_penalty": 0,
        "stop": ['\\n']
    }
    raw_response = openai.Completion.create(engine=gpt_model,
                                            prompt=prompt,
                                            **sampling_params)
    responses = [
        raw_response['choices'][i]['text'] for i in range(sampling_params['n'])
    ]
    mean_probs = [
        math.exp(
            np.mean(raw_response['choices'][i]['logprobs']['token_logprobs']))
        for i in range(sampling_params['n'])
    ]
    responses = [sample.strip().lower() for sample in responses]
    return responses[0]


def relationship_objectAB(object_A, object_B, pose_A, pose_B, relationship,
                          distance):
    '''
  assume object_B is known
  compute the object_A pose accprding to object_B pose, relationship and distance
  '''
    # print('Debug:relationship: {}'.format(relationship))
    pose_A.update(pose_B)
    # above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on, under, and center
    if 'above' == relationship:
        pose_A['x'] = pose_B['x'] + float(distance[0]) / 100. + utensil_size[
            object_A][0] * 0.5 + utensil_size[object_B][0] * 0.5
    elif 'to the right of' == relationship:
        # print('!Debug: objectA:{}, objectB:{}, pose_Ay:{}, pose_By:{}, float(distance[1]):{}., utensil_size[object_A][1]:{}, utensil_size[object_B][1]:{}'.format(object_A, object_B, pose_A['y'], pose_B['y'], float(distance[1]), utensil_size[object_A][1], utensil_size[object_B][1]))
        pose_A['y'] = pose_B['y'] - float(distance[1]) / 100. - utensil_size[
            object_A][1] * 0.5 - utensil_size[object_B][1] * 0.5
    elif 'below' == relationship:
        pose_A['x'] = pose_B['x'] - float(distance[0]) / 100. - utensil_size[
            object_A][0] * 0.5 - utensil_size[object_B][0] * 0.5
    elif 'to the left of' == relationship:
        pose_A['y'] = pose_B['y'] + float(distance[1]) / 100. + utensil_size[
            object_A][1] * 0.5 + utensil_size[object_B][1] * 0.5
    elif 'above and to the right of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] + float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] - float(distance[1]) / 100. - utensil_size[
            object_A][1] * 0.5 - utensil_size[object_B][1] * 0.5
    elif 'below and to the right of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] - float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] - float(distance[1]) / 100. - utensil_size[
            object_A][1] * 0.5 - utensil_size[object_B][1] * 0.5
    elif 'below and to the left of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] - float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] + float(distance[1]) / 100. + utensil_size[
            object_A][1] * 0.5 + utensil_size[object_B][1] * 0.5
    elif 'above and to the left of' == relationship:
        # distance of shape centers
        pose_A['x'] = pose_B['x'] + float(distance[0]) / 100.
        pose_A['y'] = pose_B['y'] + float(distance[1]) / 100. + utensil_size[
            object_A][1] * 0.5 + utensil_size[object_B][1] * 0.5
    elif 'on top of' == relationship:
        pose_A['z'] = pose_B['z'] + 0.1
    elif 'under' == relationship:
        pose_A['z'] = pose_B['z'] - 0.1
    elif 'center' == relationship:
        pass
    # print('\noutput:\n pose_A:{}, pose_B:{}, relationship:{}, distance:{}'.format(pose_A, pose_B, relationship, distance))
    # print('-'*40)


def sortdict(utensil_name_sequenced):
    # input: {'dinner knife': 0.75, 'plate': 0.65, 'fork': 0.65, 'spoon': 0.65}
    # output: {'plate': 0.65, 'fork': 0.65, 'spoon': 0.65, 'dinner knife': 0.75}
    return sorted(utensil_name_sequenced,
                  key=lambda x: utensil_name_sequenced[x])


def del_list(full_list, sub_list):
    new_full_list = [
        itemA for itemA in full_list
        if not any(itemA == itemB for itemB in sub_list)
    ]
    return new_full_list


def is_collision(x1, y1, width1, length1, x2, y2, width2, length2):
    # print('y1 - y2: {}, (length1 + length2) / 2.0: {}'.format(abs(y1 - y2), (length1 + length2) / 2.0))
    # print('x1 - x2: {}, (width1 + width2) / 2.0: {}'.format(abs(x1 - x2), (width1 + width2) / 2.0))
    if abs(x1 - x2) > (width1 + width2) / 2.0 or abs(
            y1 - y2) > (length1 + length2) / 2.0:
        return False
    else:
        return True


def get_combination(input_list):
    result = []
    for i in range(len(input_list)):
        for j in range(i + 1, len(input_list)):
            result.append((input_list[i], input_list[j]))
    return result


def get_maxkey(data):
    result = {}
    for key, value in data.items():
        result[key] = value[0] * value[1]
    max_key = max(result, key=result.get)
    # print("The item with the largest value is:", max_key)
    return max_key


def process_response(response_commonsense, zero_shot):
    # cornor case 1: xxx, xxx, xxx
    if zero_shot:
        response_commonsense = '\n'.join([
            line for line in response_commonsense.split(', ') if line.strip()
        ])  # split a long sentence into multiple lines

    # cornor case 2: plate, center --> plate, center of table
    if zero_shot:
        if 'table' not in response_commonsense and 'center' in response_commonsense:
            response_commonsense = response_commonsense.replace(
                "center", "center of the table")

    # cornor case 3: both should be placed in the center of the table. --> delete this sentece
    if zero_shot:
        lines = response_commonsense.split('\n')
        filtered_lines = [
            line for line in lines
            if not ('table' in line and not any(item in line
                                                for item in utensil_name))
        ]
        response_commonsense = '\n'.join(filtered_lines)

    # cornor case 4: if both table and center are not in sentence, assign an object in the center of object
    if 'table' not in response_commonsense and 'center' not in response_commonsense:
        response_commonsense = response_commonsense + '\n' + get_maxkey(
            utensil_size) + ' center of the table'

    # cornor case 5: remove '1.', '2.', ...
    response_commonsense = response_commonsense.split('\n')
    for index in range(len(response_commonsense)):
        response_commonsense[index] = re.sub(r'\d+\. ', '',
                                             response_commonsense[index])

    # cornor case 6: plate -> dinner plate
    # for index in range(len(response_commonsense)):
    #   if 'plate' in response_commonsense[index] and 'dinner' not in response_commonsense[index] and 'bread' not in response_commonsense[index]:
    #     response_commonsense[index] = response_commonsense[index].replace("plate", "dinner plate")

    # cornor case 7: plate -> dinner plate
    for index in range(len(response_commonsense)):
        if 'plate' in response_commonsense[
                index] and 'bread' not in response_commonsense[
                    index] and 'teacup' not in response_commonsense[index]:
            response_commonsense[index] = response_commonsense[index].replace(
                "plate", "dinner plate")

    return response_commonsense


def create_prompt_augmented_commonsense(isolated_utensil, remaining_utensil):
    prompt_hint = 'The task is to set up a dining table. The relationship between two objects can only contain the following planar relationships: above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on top of, under, and center.\n\n '
    prompt_question = 'Where should a {} be placed in relation to a {}?'.format(
        remaining_utensil, isolated_utensil)
    return prompt_hint + prompt_question


def overlap(u1_x, u1_y, u1_width, u1_length, u2_x, u2_y, u2_width, u2_length):
    left1 = u1_x - u1_width / 2
    right1 = u1_x + u1_width / 2
    top1 = u1_y + u1_length / 2
    bottom1 = u1_y - u1_length / 2

    left2 = u2_x - u2_width / 2
    right2 = u2_x + u2_width / 2
    top2 = u2_y + u2_length / 2
    bottom2 = u2_y - u2_length / 2

    if left1 > right2 or right1 < left2 or top1 < bottom2 or bottom1 > top2:
        return False
    else:
        return True


def is_inside(u1_x, u1_y, u1_width, u1_length, table_x, table_y, table_width,
              table_length):
    left1 = u1_x - u1_width / 2
    right1 = u1_x + u1_width / 2
    top1 = u1_y + u1_length / 2
    bottom1 = u1_y - u1_length / 2

    left2 = table_x - table_width / 2
    right2 = table_x + table_width / 2
    top2 = table_y + table_length / 2
    bottom2 = table_y - table_length / 2

    if left1 > left2 and right1 < right2 and top1 < top2 and bottom1 > bottom2:
        return True
    else:
        return False


def satisfy_relation(u_x, u_y, anchor_x, anchor_y, relation):
    # above, to the right of, below, to the left of, above and to the right of, below and to the right of, below and to the left of, above and to the left of, on top of, under, and center
    if relation == 'above':
        if u_x > anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == 'to the right of':
        if u_x == anchor_x and u_y < anchor_y:
            return True
        else:
            return False
    if relation == 'below':
        if u_x < anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == 'to the left of':
        if u_x == anchor_x and u_y > anchor_y:
            return True
        else:
            return False
    if relation == 'above and to the right of':
        if u_x > anchor_x and u_y < anchor_y:
            return True
        else:
            return False
    if relation == 'below and to the right of':
        if u_x < anchor_x and u_y < anchor_y:
            return True
        else:
            return False
    if relation == 'above and to the left of':
        if u_x > anchor_x and u_y > anchor_y:
            return True
        else:
            return False
    if relation == 'below and to the left of':
        if u_x < anchor_x and u_y > anchor_y:
            return True
        else:
            return False
    if relation == 'on top of':
        if u_x == anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == 'under':
        if u_x == anchor_x and u_y == anchor_y:
            return True
        else:
            return False
    if relation == '':
        return True


def plot_random_points_in_ellipse(x, y, a, b, sigma):
    M = 100
    # Generate random points within an ellipse centered at (x, y)
    theta = 2 * np.pi * np.random.rand(M)
    r = sigma * np.random.randn(M) + np.sqrt(np.random.rand(M))
    x_ellipse = x + a * r * np.cos(theta)
    y_ellipse = y + b * r * np.sin(theta)

    # Combine the x and y arrays into one array
    # points = np.column_stack((x_ellipse, y_ellipse))
    points = [list(item) for item in itertools.product(x_ellipse, y_ellipse)]

    # Plot the points
    # fig, ax = plt.subplots()
    # ax.scatter(x_ellipse, y_ellipse)
    # ax.set_aspect('equal')
    # plt.show()
    return points


'''
below functions used for pybullet-based demo
'''


class Client():

    def __init__(self):
        pybullet.connect(pybullet.DIRECT)  # pybullet.GUI for local GUI.
        pybullet.setAdditionalSearchPath(pybullet_data.getDataPath())
        pybullet.setGravity(0, 0, -9.8)

        # reset robot
        self.plane_id = pybullet.loadURDF("plane.urdf")
        self.robot_id = pybullet.loadURDF("kuka_iiwa/model_vr_limits.urdf",
                                          basePosition=[1.55, 0.0, 0.6],
                                          baseOrientation=[0.0, 0.0, 0.0, 1.0])
        jointPositions = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        for jointIndex in range(pybullet.getNumJoints(self.robot_id)):
            pybullet.resetJointState(self.robot_id, jointIndex,
                                     jointPositions[jointIndex])
            pybullet.setJointMotorControl2(self.robot_id, jointIndex,
                                           pybullet.POSITION_CONTROL,
                                           jointPositions[jointIndex], 0)

        # camera width and height
        self.cam_width = 480
        self.cam_height = 480

        # create a list to record utensil id
        self.utensil_id = {}
        self.gripper_id = None

    def render_image(self):
        # camera parameters
        cam_target_pos = [1.0, 0.0, 0.5]
        # cam_distance = 1.5
        cam_distance = 0.7
        cam_yaw, cam_pitch, cam_roll = -90, -90, 0
        cam_up, cam_up_axis_idx, cam_near_plane, cam_far_plane, cam_fov = [
            0, 0, 1
        ], 2, 0.01, 100, 60
        cam_view_matrix = pybullet.computeViewMatrixFromYawPitchRoll(
            cam_target_pos, cam_distance, cam_yaw, cam_pitch, cam_roll,
            cam_up_axis_idx)
        cam_projection_matrix = pybullet.computeProjectionMatrixFOV(
            cam_fov, self.cam_width * 1. / self.cam_height, cam_near_plane,
            cam_far_plane)
        znear, zfar = 0.01, 10.

        # get raw data
        _, _, color, depth, segment = pybullet.getCameraImage(
            width=self.cam_width,
            height=self.cam_height,
            viewMatrix=cam_view_matrix,
            projectionMatrix=cam_projection_matrix,
            shadow=1,
            flags=pybullet.ER_SEGMENTATION_MASK_OBJECT_AND_LINKINDEX,
            renderer=pybullet.ER_BULLET_HARDWARE_OPENGL)

        # get color image.
        color_image_size = (self.cam_width, self.cam_height, 4)
        color = np.array(color, dtype=np.uint8).reshape(color_image_size)
        color = color[:, :, :3]  # remove alpha channel

        # get depth image.
        depth_image_size = (self.cam_width, self.cam_height)
        zbuffer = np.float32(depth).reshape(depth_image_size)
        depth = (zfar + znear - (2 * zbuffer - 1) * (zfar - znear))
        depth = (2 * znear * zfar) / depth

        # get segment image.
        segment = np.reshape(segment,
                             [self.cam_width, self.cam_height]) * 1. / 255.
        return color, depth, segment

    def reset_video(self):
        video = imageio_ffmpeg.write_frames('video.mp4',
                                            (self.cam_width, self.cam_height),
                                            fps=60)
        video.send(None)  # seed the video writer with a blank frame
        return video

    def render_video(self, video, image):
        video.send(np.ascontiguousarray(image))

    def play_video(self):
        mp4 = open('video.mp4', 'rb').read()
        data_url = "data:video/mp4;base64," + b64encode(mp4).decode()
        return HTML(
            '<video width=480 controls><source src="%s" type="video/mp4"></video>'
            % data_url)

    def add_table(self):
        flags = pybullet.URDF_USE_INERTIA_FROM_FILE
        path = '/content/urdf_models/'

        if not os.path.exists(path):
            print('!Error: cannot find /content/urdf_models/!')
            sys.exit()

        # add table
        table_id = pybullet.loadURDF(
            "/content/urdf_models/furniture_table_square/table.urdf",
            basePosition=[1.0, 0.0, 0.0],
            baseOrientation=[0, 0, 0.7071, 0.7071])
        self.utensil_id['table'] = table_id

    def add_objects(self, utensil_name, utensil_init_pose):
        flags = pybullet.URDF_USE_INERTIA_FROM_FILE
        path = '/content/urdf_models/'

        if not os.path.exists(path):
            print('!Error: cannot find /content/urdf_models/!')
            sys.exit()

        # add objects according to utensil_name
        color = 'blue'
        color2 = 'red'
        # plate & bowl category
        if 'bread plate' in utensil_name:
            self.utensil_id['bread plate'] = pybullet.loadURDF(
                path + 'utensil_plate_circle_' + color + '_small' +
                '/model.urdf',
                basePosition=utensil_init_pose['bread plate'][0],
                baseOrientation=utensil_init_pose['bread plate'][1],
                flags=flags)
        if 'dinner plate' in utensil_name:
            self.utensil_id['dinner plate'] = pybullet.loadURDF(
                path + 'utensil_plate_circle_' + color + '/model.urdf',
                basePosition=utensil_init_pose['dinner plate'][0],
                baseOrientation=utensil_init_pose['dinner plate'][1],
                flags=flags)
        if 'fruit bowl' in utensil_name:
            self.utensil_id['fruit bowl'] = pybullet.loadURDF(
                path + 'utensil_bowl_' + color + '_big' + '/model.urdf',
                basePosition=utensil_init_pose['fruit bowl'][0],
                baseOrientation=utensil_init_pose['fruit bowl'][1],
                flags=flags)

        # fork category
        if 'dinner fork' in utensil_name:
            self.utensil_id['dinner fork'] = pybullet.loadURDF(
                path + 'utensil_fork_' + color + '/model.urdf',
                basePosition=utensil_init_pose['dinner fork'][0],
                baseOrientation=utensil_init_pose['dinner fork'][1],
                flags=flags)
        if 'salad fork' in utensil_name:
            self.utensil_id['salad fork'] = pybullet.loadURDF(
                path + 'utensil_fork_' + color + '/model.urdf',
                basePosition=utensil_init_pose['salad fork'][0],
                baseOrientation=utensil_init_pose['salad fork'][1],
                flags=flags)
        if 'dessert fork' in utensil_name:
            self.utensil_id['dessert fork'] = pybullet.loadURDF(
                path + 'utensil_fork_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['dessert fork'][0],
                baseOrientation=utensil_init_pose['dessert fork'][1],
                flags=flags)
        if 'seafood fork' in utensil_name:
            self.utensil_id['seafood fork'] = pybullet.loadURDF(
                path + 'utensil_fork_' + color + '/model.urdf',
                basePosition=utensil_init_pose['seafood fork'][0],
                baseOrientation=utensil_init_pose['seafood fork'][1],
                flags=flags)
        if 'fork' in utensil_name:
            self.utensil_id['fork'] = pybullet.loadURDF(
                path + 'utensil_fork_' + color + '/model.urdf',
                basePosition=utensil_init_pose['fork'][0],
                baseOrientation=utensil_init_pose['fork'][1],
                flags=flags)

        # knife category
        if 'butter knife' in utensil_name:
            self.utensil_id['butter knife'] = pybullet.loadURDF(
                path + 'utensil_knife_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['butter knife'][0],
                baseOrientation=utensil_init_pose['butter knife'][1],
                flags=flags)
        if 'dinner knife' in utensil_name:
            self.utensil_id['dinner knife'] = pybullet.loadURDF(
                path + 'utensil_knife_' + color + '/model.urdf',
                basePosition=utensil_init_pose['dinner knife'][0],
                baseOrientation=utensil_init_pose['dinner knife'][1],
                flags=flags)
        if 'fish knife' in utensil_name:
            self.utensil_id['fish knife'] = pybullet.loadURDF(
                path + 'utensil_knife_' + color + '/model.urdf',
                basePosition=utensil_init_pose['fish knife'][0],
                baseOrientation=utensil_init_pose['fish knife'][1],
                flags=flags)

        # spoon category
        if 'soup spoon' in utensil_name:
            self.utensil_id['soup spoon'] = pybullet.loadURDF(
                path + 'utensil_spoon_' + color + '/model.urdf',
                basePosition=utensil_init_pose['soup spoon'][0],
                baseOrientation=utensil_init_pose['soup spoon'][1],
                flags=flags)
        if 'dessert spoon' in utensil_name:
            self.utensil_id['dessert spoon'] = pybullet.loadURDF(
                path + 'utensil_spoon_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['dessert spoon'][0],
                baseOrientation=utensil_init_pose['dessert spoon'][1],
                flags=flags)
        if 'tea spoon' in utensil_name:
            self.utensil_id['tea spoon'] = pybullet.loadURDF(
                path + 'utensil_spoon_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['tea spoon'][0],
                baseOrientation=utensil_init_pose['tea spoon'][1],
                flags=flags)

        # cup & glass category
        if 'water cup' in utensil_name:
            self.utensil_id['water cup'] = pybullet.loadURDF(
                path + 'utensil_cup_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['water cup'][0],
                baseOrientation=utensil_init_pose['water cup'][1],
                flags=flags)
        if 'wine glass' in utensil_name:
            self.utensil_id['wine glass'] = pybullet.loadURDF(
                path + 'utensil_glass_' + color + '/model.urdf',
                basePosition=utensil_init_pose['wine glass'][0],
                baseOrientation=utensil_init_pose['wine glass'][1],
                flags=flags)
        if 'teacup' in utensil_name:
            utensil_init_pose['teacup'][1] = [0.0, 0.0, 0.707, 0.707]
            self.utensil_id['teacup'] = pybullet.loadURDF(
                path + 'utensil_teacup_' + color + '_big' + '/model.urdf',
                basePosition=utensil_init_pose['teacup'][0],
                baseOrientation=utensil_init_pose['teacup'][1],
                flags=flags)

        # food category
        if 'bread' in utensil_name:
            self.utensil_id['bread'] = pybullet.loadURDF(
                path + 'food_bread' + '/model.urdf',
                basePosition=utensil_init_pose['bread'][0],
                baseOrientation=utensil_init_pose['bread'][1],
                flags=flags)
        if 'strawberry' in utensil_name:
            self.utensil_id['strawberry'] = pybullet.loadURDF(
                path + 'food_strawberry' + '/model.urdf',
                basePosition=utensil_init_pose['strawberry'][0],
                baseOrientation=utensil_init_pose['strawberry'][1],
                flags=flags)

        # others
        if 'napkin' in utensil_name:
            self.utensil_id['napkin'] = pybullet.loadURDF(
                path + 'utensil_napkin_' + color + '/model.urdf',
                basePosition=utensil_init_pose['napkin'][0],
                baseOrientation=utensil_init_pose['napkin'][1],
                flags=flags)
        if 'place mat' in utensil_name:
            self.utensil_id['place mat'] = pybullet.loadURDF(
                path + 'utensil_mat_' + color2 + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['place mat'][0],
                baseOrientation=utensil_init_pose['place mat'][1],
                flags=flags)
        if 'salt shaker' in utensil_name:
            self.utensil_id['salt shaker'] = pybullet.loadURDF(
                path + 'utensil_shaker_' + color + '/model.urdf',
                basePosition=utensil_init_pose['salt shaker'][0],
                baseOrientation=utensil_init_pose['salt shaker'][1],
                flags=flags)
        if 'pepper shaker' in utensil_name:
            self.utensil_id['pepper shaker'] = pybullet.loadURDF(
                path + 'utensil_shaker_' + color + '/model.urdf',
                basePosition=utensil_init_pose['pepper shaker'][0],
                baseOrientation=utensil_init_pose['pepper shaker'][1],
                flags=flags)
        if 'teacup mat' in utensil_name:
            self.utensil_id['teacup mat'] = pybullet.loadURDF(
                path + 'utensil_mat_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['teacup mat'][0],
                baseOrientation=utensil_init_pose['teacup mat'][1],
                flags=flags)
        if 'teacup lid' in utensil_name:  # TBD
            self.utensil_id['teacup lid'] = pybullet.loadURDF(
                path + 'utensil_mat_' + color + '_small' + '/model.urdf',
                basePosition=utensil_init_pose['teacup lid'][0],
                baseOrientation=utensil_init_pose['teacup lid'][1],
                flags=flags)

        return self.utensil_id

    def get_bounding_box(self, obj_id):
        (min_x, min_y, min_z), (max_x, max_y, max_z) = pybullet.getAABB(obj_id)
        return [min_x, min_y, min_z], [max_x, max_y, max_z]

    def home_joints(self):
        jointPositions = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        for jointIndex in range(pybullet.getNumJoints(self.robot_id)):
            pybullet.resetJointState(self.robot_id, jointIndex,
                                     jointPositions[jointIndex])
            pybullet.setJointMotorControl2(self.robot_id, jointIndex,
                                           pybullet.POSITION_CONTROL,
                                           jointPositions[jointIndex], 0)

    def pick_place(self, object_name, object_id, object_position_init,
                   object_position_end, video):
        num_joints = pybullet.getNumJoints(self.robot_id)
        end_effector_index = 6
        # target_position = [0.9, -0.6, 0.65]
        target_position = [
            object_position_init[0], object_position_init[1],
            object_position_init[2] + 0.1
        ]

        for step in tqdm(range(1000)):
            if step % 4 == 0:  # PyBullet default simulation time step is 240fps, but we want to record video at 60fps.
                rgb, depth, mask = self.render_image()
                self.render_video(video, np.ascontiguousarray(rgb))

            if 'teacup' not in object_name:
                target_orientation = pybullet.getQuaternionFromEuler(
                    [0, 1.01 * math.pi, 0])
            else:
                target_orientation = pybullet.getQuaternionFromEuler(
                    [0, 1.01 * math.pi, 0.5 * math.pi])

            gripper_status = {'ungrasp': 0, 'grasp': 1}
            gripper_value = gripper_status['ungrasp']
            if step >= 150 and step < 250:
                target_position = [
                    object_position_init[0], object_position_init[1],
                    object_position_init[2] + 0.1
                ]  # grab object
                gripper_value = gripper_status['grasp']
            elif step >= 250 and step < 400:
                # target_position = [0.85, -0.2, 0.7 + 0.2*(step-250)/150.] # move up after picking object
                target_position = [
                    object_position_init[0], object_position_init[1],
                    object_position_init[2] + 0.3
                ]
                gripper_value = gripper_status['grasp']
            elif step >= 400 and step < 600:
                # target_position = [0.85, -0.2 + 0.4*(step-400)/200., 0.9] # move to target position
                target_position = [
                    object_position_init[0] +
                    (object_position_end[0] - object_position_init[0]) *
                    (step - 400) / 200, object_position_init[1] +
                    (object_position_end[1] - object_position_init[1]) *
                    (step - 400) / 200, object_position_init[2] + 0.3
                ]
                gripper_value = gripper_status['grasp']
            elif step >= 600 and step < 700:
                target_position = [
                    object_position_end[0], object_position_end[1],
                    object_position_end[2] + 0.2
                ]  # stop at target position
                gripper_value = gripper_status['grasp']
            elif step >= 700:
                target_position = [
                    object_position_end[0], object_position_end[1],
                    object_position_end[2] + 0.2
                ]  # drop object
                # print('object_name:{}, target_position:{}'.format(object_name, target_position))
                gripper_value = gripper_status['ungrasp']

            joint_poses = pybullet.calculateInverseKinematics(
                self.robot_id, end_effector_index, target_position,
                target_orientation)
            for joint_index in range(num_joints):
                pybullet.setJointMotorControl2(
                    bodyIndex=self.robot_id,
                    jointIndex=joint_index,
                    controlMode=pybullet.POSITION_CONTROL,
                    targetPosition=joint_poses[joint_index])

            if gripper_value == 0 and self.gripper_id != None:
                pybullet.removeConstraint(self.gripper_id)
                self.gripper_id = None
            if gripper_value == 1 and self.gripper_id == None:
                cube_orn = pybullet.getQuaternionFromEuler([0, math.pi, 0])
                self.gripper_id = pybullet.createConstraint(
                    self.robot_id,
                    end_effector_index,
                    object_id,
                    -1,
                    pybullet.JOINT_FIXED, [0, 0, 0], [0, 0, 0.05], [0, 0, 0],
                    childFrameOrientation=cube_orn)

            pybullet.stepSimulation()

    def disconnect(self):
        pybullet.disconnect()


"""# Utilize LLM to calculate utensil positions"""

#@title Get spatial relationship {display-mode: "form"}

#@markdown Hint: The authors recommend using Zero-shot, but in the event of any bugs, switching to Few-shot is suggested as an alternative.
zero_shot = True  #@param {type:"boolean"}

#@markdown Hint: If you select 'ChatGPT,' you'll need to manually retrieve the response through a web browser, and input each line sperately.
chatgpt = False  #@param {type:"boolean"}

# get raw response from LLM
prompt = create_prompt_relationship(utensil_name, zero_shot)
print('-' * 20 + '\nFull prompt (including {} tokens, cost {}$):\n{}\n'.format(
    count_tokens(prompt), fee_tokens(prompt), textwrap.fill(prompt, width=150))
      + '-' * 20)
if not chatgpt:
    response_commonsense = llm(prompt)
else:
    response_from_ChatGPT = input("Please enter response from ChatGPT: ")
    while True:
        response_from_ChatGPT_temp = input(
            "Please enter response from ChatGPT: ")
        if response_from_ChatGPT_temp == 'done':
            break
        response_from_ChatGPT = response_from_ChatGPT + '\n' + response_from_ChatGPT_temp
    response_commonsense = response_from_ChatGPT
print('\nLLM\'s response (raw):\n{}'.format(response_commonsense))

# process raw response
response_commonsense = process_response(response_commonsense, zero_shot)
print('\nLLM\'s response (processed):\n{}'.format(response_commonsense))

# get spatial relationship of utensils
utensils_positioning_abstract = []
for commonsense in response_commonsense:  # extract relationship
    object_A, object_B, relationship_A_B = extract_object_relationship(
        commonsense, utensil_name, relationship_name)
    utensils_positioning_abstract.append(
        [object_A, object_B, relationship_A_B])

print('\nspatial relationship of utensils:')
for item in utensils_positioning_abstract:
    print('{}'.format(item))

#@title Get deterministic physical distances {display-mode: "form", vertical-output: true }
utensils_positioning_concrete = []
for item in utensils_positioning_abstract:
    # print('item: {}'.format(item))
    if 'center' == item[2] or 'on top of' == item[2] or 'under' == item[2]:
        utensils_positioning_concrete.append([str(0), str(0)])
    else:
        prompt = create_prompt_distance(item)
        print('-' * 20 +
              '\nFull prompt (including {} tokens, cost {}$):\n{}\n'.format(
                  count_tokens(prompt), fee_tokens(prompt),
                  textwrap.fill(prompt, width=150)) + '-' * 20)
        response_commonsense_concrete = llm(prompt)
        print('LLM\'s response:\n{}'.format(response_commonsense_concrete))
        if 'top' == item[2] or 'below' == item[2]:
            distance1, distance2 = extract_distance(
                response_commonsense_concrete, 'type1')
        elif 'to the right of' == item[2] or 'to the left of' == item[2]:
            distance1, distance2 = extract_distance(
                response_commonsense_concrete, 'type2')
        elif 'above and to the right of' or 'below and to the right of' or 'below and to the left of' or 'above and to the left of':
            distance1, distance2 = extract_distance(
                response_commonsense_concrete, 'type3')
        else:
            print('!Error: Unexpected relationship type: {}'.format(item[2]))
        utensils_positioning_concrete.append([str(distance1), str(distance2)])
print('\ndistance (in centimeter) between two utensils:\n{}'.format(
    utensils_positioning_concrete))

#@title Get utensil position{display-mode: "form"}
utensils_positioning = []
for index in range(len(utensils_positioning_abstract)):
    item = utensils_positioning_abstract[index] + [
        utensils_positioning_concrete[index]
    ]
    utensils_positioning.append(item)

print('positioning of utensils:')
for item in utensils_positioning:
    print('{}'.format(item))

#@title Calculate coordinate using table's shape center as a reference. {display-mode: "form"}
'''
we ground positioning of utensils according to
1, distance in utensils_positioning
2, size of utensil
'''
utensil_goal_pose = {
    'table': {
        'x': table_x,
        'y': table_y,
        'z': 0.65
    }
}  # intialize utensil's goal pose
for item in utensil_name:
    utensil_goal_pose[item] = {
        'x': utensil_init_pose[item][0][0],
        'y': utensil_init_pose[item][0][1],
        'z': utensil_init_pose[item][0][2]
    }

utensils_positioning_cp = copy.deepcopy(
    utensils_positioning)  # copy utensils_positioning

anchor = 'table'
item_processed = []  # record items that have been processed
anchor_list = []  # save anchors
for item in utensils_positioning_cp:
    if anchor in item:
        if item.index(anchor) == 1:
            utensil = item[0]
            anchor_list.append(utensil)  # save next anchors
            item_processed.append(item)
            relationship_objectAB(utensil, anchor, utensil_goal_pose[utensil],
                                  utensil_goal_pose[anchor], item[2],
                                  item[3])  # compute utensil's goal pose
        else:
            print('!Error: Table is not world anchor by default')
            sys.exit()
if len(anchor_list) != 1:
    print(
        '!Error: Unexpected number of items that have relationship with table')
    sys.exit()
anchor = anchor_list[0]  # set next anchor
if item_processed:
    utensils_positioning_cp = del_list(
        utensils_positioning_cp,
        item_processed)  # remove items that have been processed
else:
    print('!Error: No processed item')
    sys.exit()

if utensils_positioning_cp:
    counter = 0  # count how many items have relationship with anchor
    item_processed = []  # record items that have been processed
    for item in utensils_positioning_cp:
        # print('item: {}'.format(item))
        if anchor in item and item.index(anchor) == 1:
            counter += 1
            item_processed.append(item)
            utensil = item[0]
            anchor_list.append(utensil)  # save next anchors
            # print('utensil:{}, anchor:{}, utensil_goal_pose[utensil]:{}, utensil_goal_pose[anchor]:{}, item[2]:{}, item[3]:{}'.format(utensil, anchor, utensil_goal_pose[utensil], utensil_goal_pose[anchor], item[2], item[3]))
            # print('(before)utensil_goal_pose:{}'.format(utensil_goal_pose))
            relationship_objectAB(utensil, anchor, utensil_goal_pose[utensil],
                                  utensil_goal_pose[anchor], item[2], item[3])
            # print('(after)utensil_goal_pose:{}'.format(utensil_goal_pose))
        elif anchor in item and item.index(anchor) == 0:
            counter += 1
            item_processed.append(item)
            utensil = item[1]
            anchor_list.append(utensil)  # save next anchors
            # opposite direction
            temp_relationship = opposite_direction(item[2])
            # print('temp_relationship: {}'.format(temp_relationship))
            # print('utensil:{}, anchor:{}, utensil_goal_pose[utensil]:{}, utensil_goal_pose[anchor]:{}, opposite_direction:{}, item[3]:{}'.format(utensil, anchor, utensil_goal_pose[utensil], utensil_goal_pose[anchor], temp_relationship, item[3]))
            # print('(before)utensil_goal_pose:{}'.format(utensil_goal_pose))
            relationship_objectAB(utensil, anchor, utensil_goal_pose[utensil],
                                  utensil_goal_pose[anchor], temp_relationship,
                                  item[3])
            # print('(after)utensil_goal_pose:{}'.format(utensil_goal_pose))
    if counter == 0:
        print(
            '!Error: Cannot find items that have relationship with {}'.format(
                anchor))
        sys.exit()
    utensils_positioning_cp = del_list(
        utensils_positioning_cp,
        item_processed)  # remove items that have been processed

interrupt_signal = 0
while utensils_positioning_cp and interrupt_signal <= 100:
    interrupt_signal += 1
    anchor_list_cp = copy.deepcopy(anchor_list)  # copy anchor_list
    for anchor in anchor_list_cp:
        item_processed = []  # record items that have been processed
        for item in utensils_positioning_cp:
            if anchor in item and item.index(anchor) == 1:
                item_processed.append(item)
                utensil = item[0]
                anchor_list.append(utensil)
                relationship_objectAB(utensil, anchor,
                                      utensil_goal_pose[utensil],
                                      utensil_goal_pose[anchor], item[2],
                                      item[3])
        utensils_positioning_cp = del_list(
            utensils_positioning_cp,
            item_processed)  # remove items that have been processed

if interrupt_signal == 100:
    print('!Error: Something wrong')
    sys.exit()

# sequence utensil_name according to "z"
utensil_name = sorted(utensil_name, key=lambda x: utensil_goal_pose[x]['z'])

# print final results
print('positioning result (unit is meter):')
print('world anchor: table, its pose: {}'.format(utensil_goal_pose['table']))
for item in utensil_name:
    print('utensil: {}, its pose: {}'.format(item, utensil_goal_pose[item]))

#@title Get stochastic distances (only process 3, 4 and 5 objects) {display-mode: "form", vertical-output: true }
if len(utensil_name) == 3:
    counter = 0
    points_utensil1 = []
    points_utensil2 = []
    points_utensil3 = []
    relationship_seq = []
    for item in utensil_name:
        x_center = utensil_goal_pose[item]['x']
        y_center = utensil_goal_pose[item]['y']
        print('utensil_name: {}, x_center: {:3f}, y_center: {:3}'.format(
            item, x_center, y_center))
        for item_temp in utensils_positioning:
            utensil_temp = item_temp[0]
            relationship_temp = item_temp[2]
            if utensil_temp == item:
                relationship_seq.append(relationship_temp)
                break
            else:
                continue
        # print('utensil_name:{}, relationship_temp:{}'.format(utensil_temp, relationship_temp))
        counter += 1
        points = []
        if relationship_temp == 'above' or relationship_temp == 'below':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.01,
                                                   0.03, 1.0)
        elif relationship_temp == 'to the right of' or relationship_temp == 'to the left of':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.01, 1.0)
        elif relationship_temp == 'above and to the right of' or relationship_temp == 'below and to the right of' or relationship_temp == 'below and to the left of' or relationship_temp == 'above and to the left of':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.03, 1.0)
        elif relationship_temp == 'center':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.03, 1.0)
        elif relationship_temp == 'on top of' or relationship_temp == 'under':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.0001,
                                                   0.0001, 10.0)
        else:
            print('!Error: Unexpected relationship: {}'.format(
                relationship_temp))
            sys.exit()
        if counter == 1:
            points_utensil1 = points
        elif counter == 2:
            points_utensil2 = points
        elif counter == 3:
            points_utensil3 = points
        else:
            print('!Error: Unexpected counter: {}'.format(counter))
            sys.exit()

    candidates_pair = []

    u1_width, u1_length, u1_height = utensil_size[utensil_name[0]]
    u2_width, u2_length, u2_height = utensil_size[utensil_name[1]]
    u3_width, u3_length, u3_height = utensil_size[utensil_name[2]]

    utensil_relationships = {
        'u1_u2': '',
        'u1_u3': '',
        'u2_u1': '',
        'u2_u3': '',
        'u3_u1': '',
        'u3_u2': ''
    }
    for item in utensils_positioning_abstract:
        if 'table' not in item:
            utensil_relationships['u{}_u{}'.format(
                utensil_name.index(item[0]) + 1,
                utensil_name.index(item[1]) + 1)] = item[2]
    print('utensil_name:{}'.format(utensil_name))
    print('utensil_relationships:{}'.format(utensil_relationships))

    #  on top of and under: do not sample
    for item in utensil_relationships:
        if 'on top of' in utensil_relationships[
                item] or 'under' in utensil_relationships[item]:
            print('item that has on top of and under:{}'.format(item))
            numbers = item.split("_")
            number_1 = int(numbers[0][1:])
            number_2 = int(numbers[1][1:])
            if number_1 == 1:
                if number_2 == 2:
                    points_utensil1 = points_utensil2
                elif number_2 == 3:
                    points_utensil1 = points_utensil3
            elif number_1 == 2:
                if number_2 == 1:
                    points_utensil2 = points_utensil1
                elif number_2 == 3:
                    points_utensil2 = points_utensil3
            elif number_1 == 3:
                if number_2 == 1:
                    points_utensil3 = points_utensil1
                elif number_2 == 2:
                    points_utensil3 = points_utensil2
            break

    # points_set = np.column_stack((points_utensil1, points_utensil2, points_utensil3))
    points_set = [
        list(i) for i in zip(points_utensil1, points_utensil2, points_utensil3)
    ]
    print('number of items in points_set: {}'.format(len(points_set)))

    counter = {
        'signal_1': 0,
        'signal_2': 0,
        'signal_3': 0,
        'signal_7': 0,
        'signal_8': 0,
        'signal_9': 0
    }
    for item in points_set:
        u1_x, u1_y = item[0][0], item[0][1]
        u2_x, u2_y = item[1][0], item[1][1]
        u3_x, u3_y = item[2][0], item[2][1]
        # print('u1_x:{}, u1_y:{}, u2_x:{}, u2_y:{}, u3_x:{}, u3_y:{}'.format(u1_x, u1_y, u2_x, u2_y, u3_x, u3_y))

        signal_1, signal_2, signal_3, signal_7, signal_8, signal_9 = False, False, False, False, False, False

        # hard constraint 1: no collision between two utensils
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u2_x, u2_y, u2_width,
                u2_length) or utensil_relationships[
                    'u1_u2'] == 'on top of' or utensil_relationships[
                        'u2_u1'] == 'on top of' or utensil_relationships[
                            'u1_u2'] == 'under' or utensil_relationships[
                                'u2_u1'] == 'under':
            signal_1 = True
            counter['signal_1'] += 1
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u3_x, u3_y, u3_width,
                u3_length) or utensil_relationships[
                    'u1_u3'] == 'on top of' or utensil_relationships[
                        'u3_u1'] == 'on top of' or utensil_relationships[
                            'u1_u3'] == 'under' or utensil_relationships[
                                'u3_u1'] == 'under':
            signal_2 = True
            counter['signal_2'] += 1
        if not overlap(
                u2_x, u2_y, u2_width, u2_length, u3_x, u3_y, u3_width,
                u3_length) or utensil_relationships[
                    'u2_u3'] == 'on top of' or utensil_relationships[
                        'u3_u2'] == 'on top of' or utensil_relationships[
                            'u2_u3'] == 'under' or utensil_relationships[
                                'u3_u2'] == 'under':
            signal_3 = True
            counter['signal_3'] += 1

        # hard constraint 2: cannot be outside the table
        if is_inside(u1_x, u1_y, u1_width, u1_length, table_x, table_y,
                     table_width, table_length):
            signal_7 = True
            counter['signal_7'] += 1
        if is_inside(u2_x, u2_y, u2_width, u2_length, table_x, table_y,
                     table_width, table_length):
            signal_8 = True
            counter['signal_8'] += 1
        if is_inside(u3_x, u3_y, u3_width, u3_length, table_x, table_y,
                     table_width, table_length):
            signal_9 = True
            counter['signal_9'] += 1

        if signal_1 and signal_2 and signal_3 and signal_7 and signal_8 and signal_9:
            candidates_pair.append([u1_x, u1_y, u2_x, u2_y, u3_x, u3_y])

    print('counter of signals:{}'.format(counter))

    if len(candidates_pair) > 25:
        candidates_pair = random.sample(candidates_pair, 25)

    print('number of feasible settings:{}'.format(len(candidates_pair)))

#@title Get stochastic distances (only process four objects) {display-mode: "form", vertical-output: true }
if len(utensil_name) == 4:
    counter = 0
    points_utensil1 = []
    points_utensil2 = []
    points_utensil3 = []
    points_utensil4 = []
    relationship_seq = []
    for item in utensil_name:
        x_center = utensil_goal_pose[item]['x']
        y_center = utensil_goal_pose[item]['y']
        # print('utensil_name: {}, x_center: {:3f}, y_center: {:3}'.format(item, x_center, y_center))
        for item_temp in utensils_positioning:
            utensil_temp = item_temp[0]
            relationship_temp = item_temp[2]
            if utensil_temp == item:
                relationship_seq.append(relationship_temp)
                break
            else:
                continue
        # print('utensil_name:{}, relationship_temp:{}'.format(utensil_temp, relationship_temp))
        counter += 1
        points = []
        if relationship_temp == 'above' or relationship_temp == 'below':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.01,
                                                   0.03, 1.0)
        elif relationship_temp == 'to the right of' or relationship_temp == 'to the left of':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.01, 1.0)
        elif relationship_temp == 'above and to the right of' or relationship_temp == 'below and to the right of' or relationship_temp == 'below and to the left of' or relationship_temp == 'above and to the left of':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.03, 1.0)
        elif relationship_temp == 'center':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.03, 1.0)
        elif relationship_temp == 'on top of' or relationship_temp == 'under':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.0001,
                                                   0.0001, 10.0)
        else:
            print('!Error: Unexpected relationship: {}'.format(
                relationship_temp))
            sys.exit()
        if counter == 1:
            points_utensil1 = points
        elif counter == 2:
            points_utensil2 = points
        elif counter == 3:
            points_utensil3 = points
        elif counter == 4:
            points_utensil4 = points
        else:
            print('!Error: Unexpected counter: {}'.format(counter))
            sys.exit()

    candidates_pair = []

    u1_width, u1_length, u1_height = utensil_size[utensil_name[0]]
    u2_width, u2_length, u2_height = utensil_size[utensil_name[1]]
    u3_width, u3_length, u3_height = utensil_size[utensil_name[2]]
    u4_width, u4_length, u4_height = utensil_size[utensil_name[3]]

    utensil_relationships = {
        'u1_u2': '',
        'u1_u3': '',
        'u1_u4': '',
        'u2_u1': '',
        'u2_u3': '',
        'u2_u4': '',
        'u3_u1': '',
        'u3_u2': '',
        'u3_u4': '',
        'u4_u1': '',
        'u4_u2': '',
        'u4_u3': ''
    }
    for item in utensils_positioning_abstract:
        if 'table' not in item:
            utensil_relationships['u{}_u{}'.format(
                utensil_name.index(item[0]) + 1,
                utensil_name.index(item[1]) + 1)] = item[2]
    print('utensil_name:{}'.format(utensil_name))
    print('utensil_relationships:{}'.format(utensil_relationships))

    #  on top of and under: do not sample
    for item in utensil_relationships:
        if 'on top of' in utensil_relationships[
                item] or 'under' in utensil_relationships[item]:
            print('item that has on top of and under:{}'.format(item))
            numbers = item.split("_")
            number_1 = int(numbers[0][1:])
            number_2 = int(numbers[1][1:])
            if number_1 == 1:
                if number_2 == 2:
                    points_utensil1 = points_utensil2
                elif number_2 == 3:
                    points_utensil1 = points_utensil3
                elif number_2 == 4:
                    points_utensil1 = points_utensil4
            elif number_1 == 2:
                if number_2 == 1:
                    points_utensil2 = points_utensil1
                elif number_2 == 3:
                    points_utensil2 = points_utensil3
                elif number_2 == 4:
                    points_utensil2 = points_utensil4
            elif number_1 == 3:
                if number_2 == 1:
                    points_utensil3 = points_utensil1
                elif number_2 == 2:
                    points_utensil3 = points_utensil2
                elif number_2 == 4:
                    points_utensil3 = points_utensil4
            elif number_1 == 4:
                if number_2 == 1:
                    points_utensil4 = points_utensil1
                elif number_2 == 2:
                    points_utensil4 = points_utensil2
                elif number_2 == 3:
                    points_utensil4 = points_utensil3
            break

    # points_set = np.column_stack((points_utensil1, points_utensil2, points_utensil3))
    points_set = [
        list(i) for i in zip(points_utensil1, points_utensil2, points_utensil3,
                             points_utensil4)
    ]
    print('number of items in points_set: {}'.format(len(points_set)))

    counter = {
        'signal_1': 0,
        'signal_2': 0,
        'signal_3': 0,
        'signal_4': 0,
        'signal_5': 0,
        'signal_6': 0,
        'signal_7': 0,
        'signal_8': 0,
        'signal_9': 0,
        'signal_10': 0
    }
    for item in points_set:
        u1_x, u1_y = item[0][0], item[0][1]
        u2_x, u2_y = item[1][0], item[1][1]
        u3_x, u3_y = item[2][0], item[2][1]
        u4_x, u4_y = item[3][0], item[3][1]
        # print('u1_x:{}, u1_y:{}, u2_x:{}, u2_y:{}, u3_x:{}, u3_y:{}, u4_x:{}, u4_y:{}'.format(u1_x, u1_y, u2_x, u2_y, u3_x, u3_y, u4_x, u4_y))

        signal_1, signal_2, signal_3, signal_4, signal_5, signal_6, signal_7, signal_8, signal_9, signal_10 = False, False, False, False, False, False, False, False, False, False

        # hard constraint 1: no collision between two utensils
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u2_x, u2_y, u2_width,
                u2_length) or utensil_relationships[
                    'u1_u2'] == 'on top of' or utensil_relationships[
                        'u2_u1'] == 'on top of' or utensil_relationships[
                            'u1_u2'] == 'under' or utensil_relationships[
                                'u2_u1'] == 'under':
            signal_1 = True
            counter['signal_1'] += 1
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u3_x, u3_y, u3_width,
                u3_length) or utensil_relationships[
                    'u1_u3'] == 'on top of' or utensil_relationships[
                        'u3_u1'] == 'on top of' or utensil_relationships[
                            'u1_u3'] == 'under' or utensil_relationships[
                                'u3_u1'] == 'under':
            signal_2 = True
            counter['signal_2'] += 1
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u4_x, u4_y, u4_width,
                u4_length) or utensil_relationships[
                    'u1_u4'] == 'on top of' or utensil_relationships[
                        'u4_u1'] == 'on top of' or utensil_relationships[
                            'u1_u4'] == 'under' or utensil_relationships[
                                'u4_u1'] == 'under':
            signal_3 = True
            counter['signal_3'] += 1
        if not overlap(
                u2_x, u2_y, u2_width, u2_length, u3_x, u3_y, u3_width,
                u3_length) or utensil_relationships[
                    'u2_u3'] == 'on top of' or utensil_relationships[
                        'u3_u2'] == 'on top of' or utensil_relationships[
                            'u2_u3'] == 'under' or utensil_relationships[
                                'u3_u2'] == 'under':
            signal_4 = True
            counter['signal_4'] += 1
        if not overlap(
                u2_x, u2_y, u2_width, u2_length, u4_x, u4_y, u4_width,
                u4_length) or utensil_relationships[
                    'u2_u4'] == 'on top of' or utensil_relationships[
                        'u4_u2'] == 'on top of' or utensil_relationships[
                            'u2_u4'] == 'under' or utensil_relationships[
                                'u4_u2'] == 'under':
            signal_5 = True
            counter['signal_5'] += 1
        if not overlap(
                u3_x, u3_y, u3_width, u3_length, u4_x, u4_y, u4_width,
                u4_length) or utensil_relationships[
                    'u3_u4'] == 'on top of' or utensil_relationships[
                        'u4_u3'] == 'on top of' or utensil_relationships[
                            'u3_u4'] == 'under' or utensil_relationships[
                                'u4_u3'] == 'under':
            signal_6 = True
            counter['signal_6'] += 1

        # hard constraint 2: cannot be outside the table
        if is_inside(u1_x, u1_y, u1_width, u1_length, table_x, table_y,
                     table_width, table_length):
            signal_7 = True
            counter['signal_7'] += 1
        if is_inside(u2_x, u2_y, u2_width, u2_length, table_x, table_y,
                     table_width, table_length):
            signal_8 = True
            counter['signal_8'] += 1
        if is_inside(u3_x, u3_y, u3_width, u3_length, table_x, table_y,
                     table_width, table_length):
            signal_9 = True
            counter['signal_9'] += 1
        if is_inside(u4_x, u4_y, u4_width, u4_length, table_x, table_y,
                     table_width, table_length):
            signal_10 = True
            counter['signal_10'] += 1

        if signal_1 and signal_2 and signal_3 and signal_7 and signal_8 and signal_9 and signal_10:
            candidates_pair.append([[u1_x, u1_y], [u2_x, u2_y], [u3_x, u3_y],
                                    [u4_x, u4_y]])

    print('counter of signals:{}'.format(counter))

    if len(candidates_pair) > 25:
        candidates_pair = random.sample(candidates_pair, 25)

    print('number of feasible settings:{}'.format(len(candidates_pair)))

#@title Get stochastic distances (only process four objects) {display-mode: "form", vertical-output: true }
if len(utensil_name) == 5:
    counter = 0
    points_utensil1 = []
    points_utensil2 = []
    points_utensil3 = []
    points_utensil4 = []
    points_utensil5 = []
    relationship_seq = []
    for item in utensil_name:
        x_center = utensil_goal_pose[item]['x']
        y_center = utensil_goal_pose[item]['y']
        # print('utensil_name: {}, x_center: {:3f}, y_center: {:3}'.format(item, x_center, y_center))
        for item_temp in utensils_positioning:
            utensil_temp = item_temp[0]
            relationship_temp = item_temp[2]
            if utensil_temp == item:
                relationship_seq.append(relationship_temp)
                break
            else:
                continue
        # print('utensil_name:{}, relationship_temp:{}'.format(utensil_temp, relationship_temp))
        counter += 1
        points = []
        if relationship_temp == 'above' or relationship_temp == 'below':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.01,
                                                   0.03, 1.0)
        elif relationship_temp == 'to the right of' or relationship_temp == 'to the left of':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.01, 1.0)
        elif relationship_temp == 'above and to the right of' or relationship_temp == 'below and to the right of' or relationship_temp == 'below and to the left of' or relationship_temp == 'above and to the left of':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.03, 1.0)
        elif relationship_temp == 'center':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.03,
                                                   0.03, 1.0)
        elif relationship_temp == 'on top of' or relationship_temp == 'under':
            points = plot_random_points_in_ellipse(x_center, y_center, 0.0001,
                                                   0.0001, 10.0)
        else:
            print('!Error: Unexpected relationship: {}'.format(
                relationship_temp))
            sys.exit()
        if counter == 1:
            points_utensil1 = points
        elif counter == 2:
            points_utensil2 = points
        elif counter == 3:
            points_utensil3 = points
        elif counter == 4:
            points_utensil4 = points
        elif counter == 5:
            points_utensil5 = points
        else:
            print('!Error: Unexpected counter: {}'.format(counter))
            sys.exit()

    candidates_pair = []

    u1_width, u1_length, u1_height = utensil_size[utensil_name[0]]
    u2_width, u2_length, u2_height = utensil_size[utensil_name[1]]
    u3_width, u3_length, u3_height = utensil_size[utensil_name[2]]
    u4_width, u4_length, u4_height = utensil_size[utensil_name[3]]
    u5_width, u5_length, u5_height = utensil_size[utensil_name[4]]

    utensil_relationships = {
        'u1_u2': '',
        'u1_u3': '',
        'u1_u4': '',
        'u1_u5': '',
        'u2_u1': '',
        'u2_u3': '',
        'u2_u4': '',
        'u2_u5': '',
        'u3_u1': '',
        'u3_u2': '',
        'u3_u4': '',
        'u3_u5': '',
        'u4_u1': '',
        'u4_u2': '',
        'u4_u3': '',
        'u4_u5': '',
        'u5_u1': '',
        'u5_u2': '',
        'u5_u3': '',
        'u5_u4': ''
    }
    for item in utensils_positioning_abstract:
        if 'table' not in item:
            utensil_relationships['u{}_u{}'.format(
                utensil_name.index(item[0]) + 1,
                utensil_name.index(item[1]) + 1)] = item[2]
    print('utensil_name:{}'.format(utensil_name))
    print('utensil_relationships:{}'.format(utensil_relationships))

    #  on top of and under: do not sample
    for item in utensil_relationships:
        if 'on top of' in utensil_relationships[
                item] or 'under' in utensil_relationships[item]:
            print('item that has on top of and under:{}'.format(item))
            numbers = item.split("_")
            number_1 = int(numbers[0][1:])
            number_2 = int(numbers[1][1:])
            if number_1 == 1:
                if number_2 == 2:
                    points_utensil1 = points_utensil2
                elif number_2 == 3:
                    points_utensil1 = points_utensil3
                elif number_2 == 4:
                    points_utensil1 = points_utensil4
                elif number_2 == 5:
                    points_utensil1 = points_utensil5
            elif number_1 == 2:
                if number_2 == 1:
                    points_utensil2 = points_utensil1
                elif number_2 == 3:
                    points_utensil2 = points_utensil3
                elif number_2 == 4:
                    points_utensil2 = points_utensil4
                elif number_2 == 5:
                    points_utensil2 = points_utensil5
            elif number_1 == 3:
                if number_2 == 1:
                    points_utensil3 = points_utensil1
                elif number_2 == 2:
                    points_utensil3 = points_utensil2
                elif number_2 == 4:
                    points_utensil3 = points_utensil4
                elif number_2 == 5:
                    points_utensil3 = points_utensil5
            elif number_1 == 4:
                if number_2 == 1:
                    points_utensil4 = points_utensil1
                elif number_2 == 2:
                    points_utensil4 = points_utensil2
                elif number_2 == 3:
                    points_utensil4 = points_utensil3
                elif number_2 == 5:
                    points_utensil4 = points_utensil5
            elif number_1 == 5:
                if number_2 == 1:
                    points_utensil5 = points_utensil1
                elif number_2 == 2:
                    points_utensil5 = points_utensil2
                elif number_2 == 3:
                    points_utensil5 = points_utensil3
                elif number_2 == 4:
                    points_utensil5 = points_utensil4
            break

    # points_set = np.column_stack((points_utensil1, points_utensil2, points_utensil3))
    points_set = [
        list(i) for i in zip(points_utensil1, points_utensil2, points_utensil3,
                             points_utensil4)
    ]
    print('number of items in points_set: {}'.format(len(points_set)))

    counter = {
        'signal_1': 0,
        'signal_2': 0,
        'signal_3': 0,
        'signal_4': 0,
        'signal_5': 0,
        'signal_6': 0,
        'signal_7': 0,
        'signal_8': 0,
        'signal_9': 0,
        'signal_10': 0,
        'signal_11': 0,
        'signal_12': 0,
        'signal_13': 0,
        'signal_14': 0,
        'signal_15': 0
    }
    for item in points_set:
        u1_x, u1_y = item[0][0], item[0][1]
        u2_x, u2_y = item[1][0], item[1][1]
        u3_x, u3_y = item[2][0], item[2][1]
        u4_x, u4_y = item[3][0], item[3][1]
        u5_x, u5_y = item[3][0], item[3][1]
        # print('u1_x:{}, u1_y:{}, u2_x:{}, u2_y:{}, u3_x:{}, u3_y:{}, u4_x:{}, u4_y:{}, u5_x:{}, u5_y:{}'.format(u1_x, u1_y, u2_x, u2_y, u3_x, u3_y, u4_x, u4_y, u5_x, u5_y))

        signal_1, signal_2, signal_3, signal_4, signal_5, signal_6, signal_7, signal_8, signal_9, signal_10, signal_11, signal_12, signal_13, signal_14, signal_15 = False, False, False, False, False, False, False, False, False, False, False, False, False, False, False

        # hard constraint 1: no collision between two utensils
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u2_x, u2_y, u2_width,
                u2_length) or utensil_relationships[
                    'u1_u2'] == 'on top of' or utensil_relationships[
                        'u2_u1'] == 'on top of' or utensil_relationships[
                            'u1_u2'] == 'under' or utensil_relationships[
                                'u2_u1'] == 'under':
            signal_1 = True
            counter['signal_1'] += 1
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u3_x, u3_y, u3_width,
                u3_length) or utensil_relationships[
                    'u1_u3'] == 'on top of' or utensil_relationships[
                        'u3_u1'] == 'on top of' or utensil_relationships[
                            'u1_u3'] == 'under' or utensil_relationships[
                                'u3_u1'] == 'under':
            signal_2 = True
            counter['signal_2'] += 1
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u4_x, u4_y, u4_width,
                u4_length) or utensil_relationships[
                    'u1_u4'] == 'on top of' or utensil_relationships[
                        'u4_u1'] == 'on top of' or utensil_relationships[
                            'u1_u4'] == 'under' or utensil_relationships[
                                'u4_u1'] == 'under':
            signal_3 = True
            counter['signal_3'] += 1
        if not overlap(
                u1_x, u1_y, u1_width, u1_length, u5_x, u5_y, u5_width,
                u5_length) or utensil_relationships[
                    'u1_u5'] == 'on top of' or utensil_relationships[
                        'u5_u1'] == 'on top of' or utensil_relationships[
                            'u1_u5'] == 'under' or utensil_relationships[
                                'u5_u1'] == 'under':
            signal_4 = True
            counter['signal_4'] += 1
        if not overlap(
                u2_x, u2_y, u2_width, u2_length, u3_x, u3_y, u3_width,
                u3_length) or utensil_relationships[
                    'u2_u3'] == 'on top of' or utensil_relationships[
                        'u3_u2'] == 'on top of' or utensil_relationships[
                            'u2_u3'] == 'under' or utensil_relationships[
                                'u3_u2'] == 'under':
            signal_5 = True
            counter['signal_5'] += 1
        if not overlap(
                u2_x, u2_y, u2_width, u2_length, u4_x, u4_y, u4_width,
                u4_length) or utensil_relationships[
                    'u2_u4'] == 'on top of' or utensil_relationships[
                        'u4_u2'] == 'on top of' or utensil_relationships[
                            'u2_u4'] == 'under' or utensil_relationships[
                                'u4_u2'] == 'under':
            signal_6 = True
            counter['signal_6'] += 1
        if not overlap(
                u2_x, u2_y, u2_width, u2_length, u5_x, u5_y, u5_width,
                u5_length) or utensil_relationships[
                    'u2_u5'] == 'on top of' or utensil_relationships[
                        'u5_u2'] == 'on top of' or utensil_relationships[
                            'u2_u5'] == 'under' or utensil_relationships[
                                'u5_u2'] == 'under':
            signal_7 = True
            counter['signal_7'] += 1
        if not overlap(
                u3_x, u3_y, u3_width, u3_length, u4_x, u4_y, u4_width,
                u4_length) or utensil_relationships[
                    'u3_u4'] == 'on top of' or utensil_relationships[
                        'u4_u3'] == 'on top of' or utensil_relationships[
                            'u3_u4'] == 'under' or utensil_relationships[
                                'u4_u3'] == 'under':
            signal_8 = True
            counter['signal_8'] += 1
        if not overlap(
                u3_x, u3_y, u3_width, u3_length, u5_x, u5_y, u5_width,
                u5_length) or utensil_relationships[
                    'u3_u5'] == 'on top of' or utensil_relationships[
                        'u5_u3'] == 'on top of' or utensil_relationships[
                            'u3_u5'] == 'under' or utensil_relationships[
                                'u5_u3'] == 'under':
            signal_9 = True
            counter['signal_9'] += 1
        if not overlap(
                u4_x, u4_y, u4_width, u4_length, u5_x, u5_y, u5_width,
                u5_length) or utensil_relationships[
                    'u4_u5'] == 'on top of' or utensil_relationships[
                        'u5_u4'] == 'on top of' or utensil_relationships[
                            'u4_u5'] == 'under' or utensil_relationships[
                                'u5_u4'] == 'under':
            signal_10 = True
            counter['signal_10'] += 1

        # hard constraint 2: cannot be outside the table
        if is_inside(u1_x, u1_y, u1_width, u1_length, table_x, table_y,
                     table_width, table_length):
            signal_11 = True
            counter['signal_11'] += 1
        if is_inside(u2_x, u2_y, u2_width, u2_length, table_x, table_y,
                     table_width, table_length):
            signal_12 = True
            counter['signal_12'] += 1
        if is_inside(u3_x, u3_y, u3_width, u3_length, table_x, table_y,
                     table_width, table_length):
            signal_13 = True
            counter['signal_13'] += 1
        if is_inside(u4_x, u4_y, u4_width, u4_length, table_x, table_y,
                     table_width, table_length):
            signal_14 = True
            counter['signal_14'] += 1
        if is_inside(u5_x, u5_y, u5_width, u5_length, table_x, table_y,
                     table_width, table_length):
            signal_15 = True
            counter['signal_15'] += 1

        if signal_1 and signal_2 and signal_3 and signal_7 and signal_8 and signal_9 and signal_10 and signal_11 and signal_12 and signal_13 and signal_14 and signal_15:
            # if signal_1 and signal_2 and signal_3 and signal_7 and signal_8 and signal_9 and signal_10 and signal_11 and signal_12 and signal_13:
            candidates_pair.append([[u1_x, u1_y], [u2_x, u2_y], [u3_x, u3_y],
                                    [u4_x, u4_y], [u5_x, u5_y]])

    print('counter of signals:{}'.format(counter))

    if len(candidates_pair) > 25:
        candidates_pair = random.sample(candidates_pair, 25)

    print('number of feasible settings:{}'.format(len(candidates_pair)))
with open("gpt3_log/pose_objects.json", 'w+') as outfile:
    json.dump(candidates_pair, outfile)
with open("gpt3_log/objects.json", 'w+') as outfile:
    json.dump(utensil_name, outfile)
with open("gpt3_log/abstract_pose.json", 'w+') as outfile:
    json.dump(utensil_relationships, outfile)
